CREATE SCHEMA IF NOT EXISTS bookstore
    AUTHORIZATION postgres;

-- Table: bookstore.roles

DROP TABLE IF EXISTS bookstore.roles;

CREATE TABLE bookstore.roles
(
    id   smallint,
    name character varying(20) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT roles_pkey PRIMARY KEY (id),
    CONSTRAINT unique_role_name UNIQUE (name)
)
    TABLESPACE pg_default;

ALTER TABLE bookstore.roles
    OWNER to postgres;

-- In big projects I'll consider moving db
-- population logic into a separate routine
INSERT INTO bookstore.roles
VALUES (1, 'Admin'),
       (2, 'User');

-- Table: bookstore.users

DROP TABLE IF EXISTS bookstore.users;

CREATE TABLE bookstore.users
(
    id           bigint GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 2 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    username     character varying(30) COLLATE pg_catalog."default" NOT NULL,
    email        character varying(320) COLLATE pg_catalog."default",
    created_date date                                               NOT NULL DEFAULT CURRENT_DATE,
    role_id      smallint                                           NOT NULL DEFAULT 2,
    pass_hash    character varying(60) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT unique_email UNIQUE (email),
    CONSTRAINT unique_username UNIQUE (username),
    CONSTRAINT fk_users_role_id_2_roles_id FOREIGN KEY (role_id)
        REFERENCES bookstore.roles (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)
    TABLESPACE pg_default;

ALTER TABLE bookstore.users
    OWNER to postgres;

INSERT INTO bookstore.users
VALUES (1, 'admin', NULL, CURRENT_DATE, 1,
        '$2a$04$RmTp7LrgJ9rlElxl49nAveKwSrPA1ZaRbuaM99m5SAVU0p/Pm.l16');

-- Table: bookstore.authors

DROP TABLE IF EXISTS bookstore.authors;

CREATE TABLE bookstore.authors
(
    id          integer GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    full_name   character varying(120) COLLATE pg_catalog."default" NOT NULL,
    birth_date  date,
    is_approved boolean                                             NOT NULL DEFAULT false,
    CONSTRAINT authors_pkey PRIMARY KEY (id)
)
    TABLESPACE pg_default;

CREATE UNIQUE INDEX uni_idx_author_full_name_bd
    ON bookstore.authors (full_name, birth_date)
    WHERE authors.birth_date IS NOT NULL;

CREATE UNIQUE INDEX uni_idx_author_full_name
    ON bookstore.authors (full_name)
    WHERE authors.birth_date IS NULL;

ALTER TABLE bookstore.authors
    OWNER to postgres;

-- Table: bookstore.books

DROP TABLE IF EXISTS bookstore.books;

CREATE TABLE bookstore.books
(
    id           bigint GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    name         character varying(100) COLLATE pg_catalog."default" NOT NULL,
    publish_date date                                                NOT NULL,
    author_id    integer,
    creator_id   bigint                                              NOT NULL,
    price        numeric                                             NOT NULL,
    description  character varying(300) COLLATE pg_catalog."default",
    is_approved  boolean                                             NOT NULL DEFAULT false,
    is_deleted   boolean                                             NOT NULL DEFAULT false,
    CONSTRAINT books_pkey PRIMARY KEY (id),
    CONSTRAINT fk_books_author_id_2_authors_id FOREIGN KEY (author_id)
        REFERENCES bookstore.authors (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_books_creator_id_2_users_id FOREIGN KEY (creator_id)
        REFERENCES bookstore.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)
    TABLESPACE pg_default;

CREATE UNIQUE INDEX uni_idx_book_name_pub_dt_ar_id_cr_id
    ON bookstore.books (name, publish_date, author_id, creator_id)
    WHERE author_id IS NOT NULL AND is_deleted = false;

CREATE UNIQUE INDEX uni_idx_book_name_pub_dt_cr_id
    ON bookstore.books (name, publish_date, creator_id)
    WHERE author_id IS NULL AND is_deleted = false;

CREATE INDEX fki_books_author_id_2_authors_id
    ON bookstore.books USING btree
        (author_id ASC NULLS LAST);

CREATE INDEX fki_books_creator_id_2_users_id
    ON bookstore.books USING btree
        (creator_id ASC NULLS LAST);

ALTER TABLE bookstore.books
    OWNER to postgres;

-- Table: bookstore.comments

DROP TABLE IF EXISTS bookstore.comments;

CREATE TABLE bookstore.comments
(
    id           bigint GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    book_id      bigint                                              NOT NULL,
    commenter_id bigint                                              NOT NULL,
    text         character varying(300) COLLATE pg_catalog."default" NOT NULL,
    commented_at timestamp                                           NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT comments_pkey PRIMARY KEY (id),
    CONSTRAINT fk_books_book_id_2_books_id FOREIGN KEY (book_id)
        REFERENCES bookstore.books (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_comments_commenter_id_2_users_id FOREIGN KEY (commenter_id)
        REFERENCES bookstore.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)
    TABLESPACE pg_default;

CREATE INDEX fki_books_book_id_2_books_id
    ON bookstore.comments USING btree (book_id);

CREATE INDEX fki_comments_commenter_id_2_users_id
    ON bookstore.comments USING btree (commenter_id);

ALTER TABLE bookstore.comments
    OWNER to postgres;
